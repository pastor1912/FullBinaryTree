<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Binary Tree with Canvas</title>
    <style>
      #canvas {
        border: 1px solid black;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <input id="node-id" />
    <button id="add-node">add-node</button>

    <button id="zoom-in">zoom-in</button>
    <button id="zoom-out">zoom-out</button>
    <script>
      class Nodes {}
      class Node {
        constructor(value, x, y, id) {
          this.value = value;
          this.left = null;
          this.right = null;
          this.x = x;
          this.y = y;
          this.id = id;
          this.width = 30;
          this.height = 30;
        }

        draw(ctx) {
          ctx.fillStyle = "#fff";
          ctx.strokeStyle = "#000";
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.width / 2, 0, 2 * Math.PI);
          ctx.fill();
          ctx.stroke();
          ctx.fillStyle = "#000";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(this.id, this.x, this.y);
          ctx.fillText(this.value, this.x, this.y + this.width / 2 + 10);
        }
      }

      class BinaryTree {
        constructor(x, y, canvas) {
          this.root = null;
          this.x = x;
          this.y = y;
          this.canvas = canvas;
          this.viewport = {
            x: 0,
            y: 0,
            scale: 1,
          };
        }
        addNode(id) {
          const node = new Node(
            id,
            this.x,
            this.y,
            Math.floor(Math.random() * 1000)
          );
          if (!this.root) {
            this.root = node;
          } else {
            let current = this.root;
            while (true) {
              if (id < current.value) {
                if (!current.left) {
                  current.left = node;
                  break;
                }
                current = current.left;
              } else {
                if (!current.right) {
                  current.right = node;
                  break;
                }
                current = current.right;
              }
            }
          }
          this.repositionNodes(this.root, this.x, this.y, 1);
        }

        repositionNodes(node = this.root, x = canvas.width / 2, y = 50) {
          if (!node) return;
          const dx = 50 * Math.pow(2, -level);
          const dy = 50;
          node.x = x + this.viewport.x;
          node.y = y + this.viewport.y;
          this.repositionNodes(node.left, x - dx, y + dy, level + 1);
          this.repositionNodes(node.right, x + dx, y + dy, level + 1);
        }

        draw(ctx) {
          ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          if (!this.root) return;
          this.root.draw(ctx);
          this.drawTree(this.root.left, ctx);
          this.drawTree(this.root.right, ctx);
        }
        drawTree(node, ctx) {
          if (!node) return;
          node.draw(ctx);
          this.drawTree(node.left, ctx);
          this.drawTree(node.right, ctx);
        }

        zoomIn() {
          this.viewport.scale *= 1.1;
          this.repositionNodes(this.root, this.x, this.y, 1);
        }

        zoomOut() {
          this.viewport.scale /= 1.1;
          this.repositionNodes(this.root, this.x, this.y, 1);
        }

        pan(dx, dy) {
          this.viewport.x += dx / this.viewport.scale;
          this.viewport.y += dy / this.viewport.scale;
          this.repositionNodes(this.root, this.x, this.y, 1);
        }

        traverseDFS(callback) {
          (function recurse(currentNode) {
            callback(currentNode);
            currentNode.leftChild && recurse(currentNode.leftChild);
            currentNode.rightChild && recurse(currentNode.rightChild);
          })(this.root);
        }

        traverseBFS(callback) {
          const queue = [this.root];
          while (queue.length) {
            const currentNode = queue.shift();
            const result = callback(currentNode);
            if (result) {
              return result;
            }
            currentNode.leftChild && queue.push(currentNode.leftChild);
            currentNode.rightChild && queue.push(currentNode.rightChild);
          }
        }

        toggleMinimizeNode(node) {
          if (this.minimizedNodes.has(node)) {
            this.minimizedNodes.delete(node);
          } else {
            this.minimizedNodes.add(node);
          }
          this.repositionNodes();
        }
      }

      //   tree.addNode(2);
      //   tree.addNode(3);
      //   tree.addNode(4);
      //   tree.addNode(5);
      //   tree.addNode(6);
      //   tree.addNode(7);

      //   tree.draw(ctx);
      //   function animate() {
      //     tree.draw(ctx);
      //     requestAnimationFrame(animate);
      //   }

      //   animate();
    </script>
  </body>
</html>
